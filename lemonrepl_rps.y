%include {
  /************************************************************************
   * file lemonrepl_rps.y
   * SPDX-License-Identifier: GPL-3.0-or-later
   *
   * Description:
   *
   *      This lemonrepl_rps.y file is part of the Reflective
   *      Persistent System.  It is the input to lemon parser
   *      generator (from sqlite.org) to generate parsing code.
   *
   *      © Copyright 2023 The Reflective Persistent System Team
   *      team@refpersys.org & http://refpersys.org/
   *
   * Note that the lemon parser generator is documented in
   * https://sqlite.org/src/doc/trunk/doc/lemon.html
   * or on Debian-like distributions in /usr/share/doc/lemon/lemon.html
   *
   ************************************************************************/

 #include "refpersys.hh"


  constexpr unsigned long RpsLemon_Arg_Magic =8286934847; // 0x1edf0973f
  
  struct RpsLemon_Parsing_Argument {
    unsigned long lemparg_magic; /* should be RpsLemon_Arg_Magic */
    RpsCallStack* lemparg_stack;
    RpsTokenSource lemparg_toksrc;
    void* lemparg_xtra;
  };

  constexpr unsigned long RpsLemon_Ctx_Magic = 26589934843; // 0x630e234fb
  
  struct RpsLemon_Parsing_Context {
    unsigned long lempctx_magic; /* should be  RpsLemon_Ctx_Magic */
    struct RpsLemon_Parsing_Argument* lempctx_arg;
    void* lempctx_xtra;
  };
 }

/// By default, the functions generated by Lemon all begin with the
/// five-character string "Parse". You can change this string to
/// something different using the %name directive.
%name RpsLemParse_

/// The %extra_argument directive instructs Lemon to add a 4th
/// parameter to the parameter list of the Parse() function it
/// generates.
%extra_argument { RpsLemon_Parsing_Argument* parsarg }


/// The %extra_context directive instructs Lemon to add a 2nd
/// parameter to the parameter list of the ParseAlloc() and
/// ParseInit() functions.
%extra_context { RpsLemon_Parsing_Context* parsctx }

// All token codes are small integers with #defines that begin with "RPSREPL_TOKEN_LEMON_"
// see §4.4.23 https://sqlite.org/src/doc/trunk/doc/lemon.html#token_prefix
%token_prefix RPSREPL_TOKEN_LEMON_

// The type of the data attached to each token is Rps_LexTokenValue
 // See §4.4.24  https://sqlite.org/src/doc/trunk/doc/lemon.html#token_type
%token_type {Rps_LexTokenValue}

// See  §4.4.23   https://sqlite.org/src/doc/trunk/doc/lemon.html#default_type
// The %default_type directive specifies the data type of
// non-terminal symbols that do not have their own data type defined
// using a separate %type directive.
%default_type {Rps_Value}


%start_symbol lemrepl_command 

%token INTEGER STRING FLOAT OID NAME NIL .

%token LEFTPAREN RIGHTPAREN DOT COLON LEFTBRACKET RIGHTBRACKET .

 /// keywords
%token SHOW PUT IN DO REMOVE .

 /// command to show something
lemrepl_command ::= SHOW value_expr(v) .
  {
#warning missing code for SHOW command
  }

/// command to put an attribute in an object
lemrepl_command ::= IN obj_expr(ob) PUT obj_expr(obat)
                    COLON value_expr(valat) .
  {
#warning missing code to put an attribute in an object
  }
   ///
lemrepl_command ::= IN obj_expr(ob)  REMOVE obj_expr(obat) .
  {
#warning missing code to remove an attribute in an object
    RPS_FATALOUT("missing code to remove an attribute in an object");
  }

obj_expr ::= NAME .

obj_expr ::= OID .
   
/// TODO: lots of other rules for obj_expr are missing

value_expr ::= INTEGER .

value_expr ::= STRING .

value_expr ::= FLOAT .



/// TODO: lots of other rules for value_expr are missing!

value_expr ::= obj_expr(ob) DOT obj_expr(obat) .
  {
#warning missing code to get an attribute in an object
    RPS_FATALOUT("missing code to get an attribute in an object");
  }


value_expr ::= obj_expr(ob) LEFTBRACKET value_expr(v) RIGHTBRACKET
.
  {
#warning missing code to get a component in an object
    RPS_FATALOUT("missing code to get a component in an object");
  }

