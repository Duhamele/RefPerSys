
%% file doc/iccait-2021/iccait2021-refpersys.tex
%% on https://gitlab.com/bstarynk/refpersys
%% a submission to https://panel.waset.org/conference/2021/05/paris/ICCAIT
%% use the ./build.sh script to generate the PDF
%% see in subdirectory latex-fullpaper-template/ the original LaTeX templates.
%% see the README.md file, giving typographical hints.
%
%\documentclass[journal]{journal}
\documentclass{IEEEtran}
%% most of the LaTeX comments from  latex-fullpaper-template/journal.tex have been removed.
%% please refer to that LaTeX file.
% See LaTeX guidelines on https://mirrors.chevalier.io/CTAN/macros/latex/contrib/IEEEtran/IEEEtran_HOWTO.pdf
% and BibTeX guidelines on https://ctan.tetaneutral.net/macros/latex/contrib/IEEEtran/bibtex/IEEEtran_bst_HOWTO.pdf

\usepackage{hyperref}

% see https://www.ctan.org/pkg/biblatex-ieee
% see https://www.ctan.org/pkg/biber
%-\usepackage[backend=biber,bibencoding=utf8,style=ieee]{biblatex}
\usepackage[backend=biber,style=ieee]{biblatex}
\addbibresource{iccait2021-refpersys-biblio}

 \usepackage[pdftex]{graphicx}

\usepackage{svg}

\usepackage{relsize}
\pagestyle{empty}

\newcommand{\RefPerSys}{{\textit{\textsc{RefPerSys}}}}

% defines the \rpsgitcommit command:
\input{generated-iccait2021-gitid}
% defines the \rpstimestamp command:
\input{generated-iccait2021-timestamp}

\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{Design ideas and implementation issues in \RefPerSys, a free software reflexive persistent system for AI}
%

\author{Basile Starynkevitch, \and Abhishek Chakravarti}
\thanks{Contacts:
  \href{mailto:basile@starynkevitch.net}{\texttt{basile@starynkevitch.net}}
  (Bourg-la-Reine, near Paris, France) and
  \href{mailto:abhishek@taranjali.org}{\texttt{abhishek@taranjali.org}}
  (Kolkata, India), and collectively
  \href{mailto:team@refpersys.org}{\texttt{team@refpersys.org}}}



% The paper headers
\markboth{Journal of \LaTeX\ Class Files,~Vol.~6, No.~1, January~2007}%
{Shell \MakeLowercase{\textit{et al.}}: Bare Demo of IEEEtran.cls for Journals}
% The only time the second header will appear is for the odd numbered pages
% after the title page when using the twoside option.
% 



\maketitle
\thispagestyle{empty}


\begin{abstract}
%\boldmath
%%VISIBLE++

  %%% maximum 500 words
  
The technical progress of computing hardware, especially with the
prevalence of multicore systems and large amounts of RAM, now allows
us to further experiment with the orthogonally persistent and
reflexive systems for symbolic artificial intelligence approaches.
The RefPerSys system is a free software (GPlv3+ licensed) prototype,
running on a Linux desktop, experimenting these ideas.

Our project is a work in progress exploring the development, through
the use of metaprogramming approaches, a bootstrapped multithreaded,
reflexive and orthogonally persistent Quine system running on modern
Linux x86-64 hardware, leading to a declarative knowledge-based
language.

A garbage collected memory heap, persisted on disk, containing a mix
of flexible and mutable objects and immutable but structured values,
many of them refering to objects, is loaded at startup, and dumped at
shutdown into mostly textual files and posssibly other stores. That
heap also contains transient data which cannot or should not be
persisted.

A collection of flexible objects can reify and represent executable
code, practially emitted as generated C++ files, using a bootstrapping
and metaprogramming approach. So the emitted code of the system is
generated from a semantic network processed by the system
itself. RefPerSys objects are frames, having a class, with a flexible
set of attributes, components, and some optional payload carrying
extra data.

Introspection becomes possible by inspecting the call stack, made of
reified garbage collected call frames.

The infrastructure code of RefPerSys (garbage collection and
persistence support) is at first hand-written C++ code which gets
progressively replaced by generated C++ code, thanks to RefperSys'
growing persistent heap. The initial GC is naive, but should be
replaced by a more efficient and more thread-friendly garbage
collector, whose C++ code is machine generated by the system itself.

This approach should foster a self-adaptative system. Thanks to
metaprogramming, runtime introspection of the call stacks, millisecond
measurement of runtime, and coding rules and heuristics explicitly
represented in a more and more declarative way, the RefPerSys system
could adapt itself to its current subproblems or the computer it is
running on.

%%VISIBLE--
\end{abstract}


% Note that keywords are not normally used for peerreview papers.
\begin{IEEEkeywords}
Agent-based and Multi-agent Systems, Knowledge Representation and Reasoning,
  Machine Learning, Multidisciplinary Topics and Applications, Semantic
  Technologies.
\end{IEEEkeywords}






% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle



\section{Introduction}
Our complex, but fragile, world is facing dramatic and extremely challenging
planet-wide issues, such global warming, demographic and political crises,
economic and financial emergencies, and growing inqualities. In the light of
such challenges, \textbf{A}rtificial \textbf{G}eneral \textbf{I}ntelligence
(\emph{AGI}) systems are increasingly relevant.

We believe in free software \index{free software} (read also
\href{https://www.fsf.org/about/what-is-free-software}{this}), and we
strongly believe that an AGI prototype should be some free software,
exactly like most infrastructure software are (notably
\textsc{Linux}). See also the
\href{https://www.softwareheritage.org/}{\textsc{Software Heritage}
  project} \index{softwareheritage@\textsc{Software Heritage}} for interesting insights. \textsc{RefPerSys} wants to be an
AGI infrastructure \index{infrastructure}, and there is work for many years (several years of
work needed without any ``artificial intelligence'', just for the
infrastructure).

An even partially successful \textsc{AGI} system might be useful to
coordinate, run and manage other existing software (described through
some knowledge given declaratively). Imagine how complex future
\href{https://en.wikipedia.org/wiki/Digital_twin}{digital twins} of
the entire planet Earth, designed to tackle with global warming, would
need to be. For such dramatically complex usage, an AGI system (like
{\RefPerSys}, if we succeed in making it) could be quite helpful to
just drive and use such a ``digital twin'' simulation. Making it free
software runnable on a free software operating system should benefit
most of humanity (but keeping it proprietary won't), and enable
further or alternative experimentations. And
``\href{https://theresnoplanetb.net/}{there is no planet
  B}''. So investing a few persons willing to working
for nearly a decade is not too much for such a perspective.

A symbolic AI software system running on \textsc{Linux} nowadays needs to
manage a large amount of information and knowledge organized as some
complex graph (also known as an \emph{ontology}
\cite{DeNicola:2009:OntologyBuilding}, a \emph{semantic network}
\cite{VanDeRiet:1992:Ling-instr-know}, or a \emph{frame}
\cite{Bobrow-Winograd:1977:KRL, Lenat:1983:theory}) inside the
computer memory. 

This large graph should be orthogonally persistent
\cite{Dearle:2010:orthopersist} (such as in \textsc{Bismon}
\cite{Starynkevitch:2019:bismon-draft}) on disk, and be loaded from
files at startup time on mornings of worked days, and later dumped to
disk, as a set of \emph{state files} in JSON format, before
normal termination when leaving office at evening. Having these files
in a textual format facilitates their management with existing
distributed version control systems such as
\href{http://git-scm.com}{\texttt{git}} or software development forges
like \href{http://gitlab.com/}{\texttt{gitlab}} and ensures some data
portability.

Current desktop computers are powerful enough to keep a large memory heap in
%%
%RAM\footnote{Notice that the C++ source of software (such as the
%\textsc{Gcc} compiler, the \textsc{Qt} GUI toolkit, or the
%\textsc{PostGreSQL} database) made of millions of lines of code fits
RAM\footnote{Notice that the millions of SLOC for mature software (such as the
\textsc{Gcc} compiler, the \textsc{Qt} GUI toolkit, or the
\textsc{PostGreSQL} database), fits entirely in the 64 GB RAM of a powerful desktop. 
But compiling such a code base takes hours of computer time.}, and this entire heap
%%
%can be persisted on disk, in a manner similar to relational database management systems
%\cite{levene:2012:relational-databases} such as
%\href{http://sqlite.org/}{\textsc{Sqlite}} or \textit{NoSQL} databases
%\cite{RAJ-2018-NoSQL} do. 
can be persisted on disk, similar to how database management systems
%\cite{levene:2012:relational-databases} such as
%\href{http://sqlite.org/}{\textsc{Sqlite}} or \textit{NoSQL}\cite{RAJ-2018-NoSQL} work. 
such as \href{http://sqlite.org/}{\textsc{Sqlite}} or \href{https://en.wikipedia.org/wiki/NoSQL}{\textit{NoSQL}} work. 

Current processors are multi-core, so running a good enough multi-threaded program on them
\cite{butenhof:1997:programming} should be beneficial for
performance. Backtracing libraries such as I. Taylor's
\href{https://github.com/ianlancetaylor/libbacktrace}{\texttt{libbacktrace}}
facilitate introspection of the current thread's call stack, if the
\emph{C++} code has been compiled, using \texttt{g++ -O2 -g}, with
\textsc{Dwarf} debugging information. JIT-compiling libraries (such as
\href{https://gcc.gnu.org/onlinedocs/jit/}{\texttt{libgccjit}}) can
produce plugins without the need of a textual representation of some
\href{https://en.wikipedia.org/wiki/Abstract_syntax_tree}{AST} of the
code.

%\hfill mds
 
%\hfill January 11, 2007

\subsection{A Staircase Development Model}
\label{subsec:staircase}
%% copied text and figure from refpersys-design.tex & spiral-stairs.svg
{\RefPerSys} development model is similar to a staircase, as depicted
%in figure \ref{fig:bootstrap-stair}. It is different from the
%traditional spiral development model \cite{boehm:1988:spiral}. The
in Figure \ref{fig:bootstrap-stair}, unlike the traditional spiral development
model \cite{boehm:1988:spiral}. The
%initial
floor of the staircase is just a C++ hand-coded persistent
system, and we gradually add new code implementing more features
(first entirely hand-written, later more and more parts of it being replaced
by {\RefPerSys} generated code). We are progressively replacing
existing hand-written code (or low-level DSL) by more a expressive and
generated one\footnote{Currently, as of August 2020, \RefPerSys has 183 lines of generated code as
compared to 17,337 lines of hand-written code.}. So we will continuously rewrite past
formalizations as more clever and expressive ones, taking increasing advantage of
{\RefPerSys} %whole-system 
system-wide introspective and metaprogramming abilities.


\begin{figure}[h]
  \begin{center}
    \includesvg[width=0.32\textwidth]{spiral-stairs}
  \end{center}

  \begin{quote}
    %\begin{relsize}{-0.4}
    Each new feature -or small incremental change or a few of them
    (small \texttt{git commit}s) - of {\RefPerSys} enables us to build
    and \textbf{generate} the next version of {\RefPerSys}, and a next
    feature is then added to that \textit{improved} version, and so on
    repeatedly, etc....
    %\end{relsize}
  \end{quote}
  
  \caption{the strange \textbf{{\RefPerSys} staircase development model} 
	(from a \href{https://thenounproject.com/term/spiral-stairs/956427/}
	{figure of Spiral stairs} by Lluisa Iborra from the Noun Project)}
  \label{fig:bootstrap-stair}
\end{figure}


So the {\RefPerSys} project is taking a bootstrapping\footnote{By bootstrapping,
we mean in the sense of a self-compiling compiler, and not as in the statistical
sense of the term.} approach
\cite{Pitrat:1996:FGCS, Pitrat:2009:ArtifBeings,
  hernandez-phillips:2019:debugging-bootstrap} : progressively old
code (perhaps even hand-written, or generated) is replaced by
``better'' code emitted by metaprogramming techniques from higher
level formalizations.


\subsection{Initial Architecture of \RefPerSys}
\label{subsec:initarch}

The initial architecture\footnote{The GPLv3+ code of \textsc{Bismon},
mostly in C, is available on
\href{https://github.com/bstarynk/bismon/}{\texttt{github.com/bstarynk/bismon/}}. But
     {\RefPerSys} is coded in C++, only for \textsc{Linux/x86-64}, on
     \href{https://gitlab.com/bstarynk/refpersys}{\texttt{gitlab.com/bstarynk/refpersys}}
     and share almost no code with \textsc{Bismon}.}, prototyped in
C++17, of {\RefPerSys} is close to \textsc{Bismon}'s one. But it
should evolve very differently. Our persistent and garbage-collected
\cite{jones:2016:gchandbook} heap is made of \emph{values}. Most
values are immutable and rather light. Some values are mutable
\emph{objects}, which are quite heavy, since synchronized between
threads so carrying their read-write lock.


\subsubsection{Values in  \RefPerSys}

Values in {\RefPerSys} are most often immutable values, or mutable
objects. All of them are ordered -so comparable-, and hashable. Each
value has a type (for objects, their type is their class). The
\texttt{null} pointer is special and understood as lack of value (so
is less than any other value). Values are garbage collected
\cite{jones:2017:gchandbook}. A clever GC would handle differently
immutable values (they could be allocated quickly with some copying
generational approach) and mutable objects\footnote{Objects cannot be
moved by the GC, if represented as C++ objects, since several threads
could use them and since they need to contain mutexes}.

Immutable values are:

\begin{itemize}
\item \textbf{scalar values} (inspired by Lisp) such as strings,
  tagged integers, boxed floating point numbers (not a NaN, to remain
  ordered), constant (small) arrays of numbers.
\item \textbf{composite values} (memoizing their hash code), i.e.:
  \begin{itemize}
  \item constant \textbf{tuples} or sequences of object references (ordered
    lexicographically).
  \item constant finite \textbf{sets} of object references, represented as
    ordered arrays, so with logarithmic membership test.
  \item \textbf{closures}: a closure has some code represented by an
    connective object (containing a C++ function pointer used for
    applying that closure) with a constant finite sequence of closed
    values.
  \item \textbf{immutable instances} share with closure some C++
    representation (and GC code). The [connective] object is then
    instance's class, and the values can be understood as constant and
    immutable fields. They are mimicking objects (see below) but stay
    immutable, so fields -i.e. values after the connective- are
    interpreted as attributes or as components.
  \end{itemize}
\end{itemize}

Only {\RefPerSys} objects are mutable, and in a multi-threading
approach are quite heavy, since every object needs to be protected by
its mutex (mutual exclusion lock). An object contains:


\begin{itemize}
\item its \textbf{mutex}, a \texttt{std::recursive\_mutex} in C++ parlance.
\item the object's \textbf{class}, which is itself an object.
\item a C++ pointer to some function, used for applying closure
  \item attribute entries: an abstract finite sorted mapping
    (initially, some \texttt{std::map} in C++ parlance) from objects
    to values. Each attribute is an object, and all of them are
    different. The value of an object is arbitrary but non-nil and can
    be changed.
  \item object components: a sequence (e.g. \texttt{std::vector}) of
      values, some of them could be null.
    \item an optional payload, see below. Payload are arbitrary data
      carrying something more. For classes, they would carry the
      method dictionary and the superclass.
\end{itemize}

The object model is basically the ObjVLisp's one
\cite{cointe:1987:metaclasses}. Every non-nil value has a class, and
can be sent a message. The selector of a message is an object. The
arguments of message sending are a sequence of arbitrary values. The
reciever of a message is an non-nil value.

Each class contains as its payload a class information payload, with: the superclass, the dictionary mapping selector to method implementations (closures), 
\medskip


Values are represented in memory as
64 bits machine words: either a tagged integer, or containing a
pointer to some aligned memory zone. Most values are persistent---so
dumped then later reloaded through state files---but some are transient,
since it makes no sense to keep them on disk. Transient values, often
transient objects, include reification of GUI windows or Web widgets,
HTTP connections, ongoing processes, in particular compilation
commands of newly generated plugins, etc.. Values are both ordered
and hashable, so fit nicely inside standard C++ containers like
\texttt{std::set} or \texttt{std::unordered\_map}. Every mutable
object has a globally unique, fixed, and random \emph{objid}, which
fits in 16 bytes and is textually represented---in state files---with a
string such as \texttt{\_7VnQtHZ63pA02rCekc}.

Immutable values include \textsc{Utf-8} strings, boxed \textsc{Ieee}
64 bits floats without \texttt{NaN} to stay ordered, tuples of
references to objects, ordered sets of objects, closures -whose code
is represented by some object, and with arbitrary values as closed
values-, and immutable instances.

Mutable objects carry their constant \emph{objid}, their lock, their
class -which could change at runtime and is an object-, attributes,
components, and some optional smart \texttt{std::unique\_ptr} pointer
to the payload of that object. An attribute associates a key -itself
some object reference- to a value, so attributes are collected in some
mutable C++ \texttt{std::map}. The components are organized as a
\texttt{std::vector} of values. The payload belongs to its owning
object and carry extra data, such as mutable hashed sets, class
information -sequence of superclasses and method dispatch table-,
string buffers, opened file or socket handles, GUI or widgets etc..

%%%
%The initial {\RefPerSys} should contain some ad-hoc integrated
%development environment above the \textsc{Fltk} toolkit, used just to
%fill the persistent heap and generate some of its C++ code.
%%%
{\RefPerSys} will initially have an ad-hoc IDE---built with the \textsc{Fltk}
toolkit---to just fill the persistent heap and generate some of its C++
code. This IDE will support the syntax highlighting, autocompletion and
navigating of objects through their \emph{objids}.

\subsection{Metaprogramming In \RefPerSys}
\label{subsec:metaprogramming}

An essential insight of {\RefPerSys} is metaprogramming, practically
done by generating \emph{C++17} code at runtime for a Linux
system. This is strongly inspired by previous work, see
\cite{Pitrat:1996:FGCS, Pitrat:2009:ArtifBeings,
  Starynkevitch:2019:bismon-draft, Starynkevitch-DSL2011,
  Starynkevitch:2007:Multistage}. The choice of the actual programming
language used to generate code\footnote{In practice, some C++ code is
emitted in a file similar to \texttt{/tmp/generated.cc}, compiled as a
plugin by forking \texttt{g++ -O -g -fPIC -shared} into a
\texttt{/tmp/generated.so}, which is later \texttt{dlopen}-ed, all by
the same process running the \texttt{./refpersys} executable.} in
within {\RefPerSys} is mostly arbitrary and guided by non-technical
concerns: which programming language is known to all the {\RefPerSys}
team, while being compatible with a lot of existing open source
libraries and APIs? That programming language happens to be C++
(better than C, because of its containers; also used in
\href{http://tensorflow.org}{\textsc{TensorFlow}} or
\href{https://gudhi.inria.fr/}{\textsc{Ghudi}}), but our expansion
machinery is inspired by \textsc{Melt} code chunks
\cite{Starynkevitch-DSL2011}, \textsc{Lisp} macros
\cite{Queinnec:1996:LSP} or \textsc{Django} templates, driven by
``expert system''-like meta rules (such as in \cite{Pitrat:1996:FGCS})
potentially applicable to themselves.

% needed in second column of first page if using \IEEEpubid
%\IEEEpubidadjcol

%\subsubsection{Subsubsection Heading Here}
%Subsubsection text here.


% An example of a floating figure using the graphicx package.
% Note that \label must occur AFTER (or within) \caption.
% For figures, \caption should occur after the \includegraphics.
% Note that IEEEtran v1.7 and later has special internal code that
% is designed to preserve the operation of \label within \caption
% even when the captionsoff option is in effect. However, because
% of issues like this, it may be the safest practice to put all your
% \label just after \caption rather than within \caption{}.
%
% Reminder: the "draftcls" or "draftclsnofoot", not "draft", class
% option should be used if it is desired that the figures are to be
% displayed while in draft mode.
%
%\begin{figure}[!t]
%\centering
%\includegraphics[width=2.5in]{myfigure}
% where an .eps filename suffix will be assumed under latex, 
% and a .pdf suffix will be assumed for pdflatex; or what has been declared
% via \DeclareGraphicsExtensions.
%\caption{Simulation Results}
%\label{fig_sim}
%\end{figure}

% Note that IEEE typically puts floats only at the top, even when this
% results in a large percentage of a column being occupied by floats.


% An example of a double column floating figure using two subfigures.
% (The subfig.sty package must be loaded for this to work.)
% The subfigure \label commands are set within each subfloat command, the
% \label for the overall figure must come after \caption.
% \hfil must be used as a separator to get equal spacing.
% The subfigure.sty package works much the same way, except \subfigure is
% used instead of \subfloat.
%
%\begin{figure*}[!t]
%\centerline{\subfloat[Case I]\includegraphics[width=2.5in]{subfigcase1}%
%\label{fig_first_case}}
%\hfil
%\subfloat[Case II]{\includegraphics[width=2.5in]{subfigcase2}%
%\label{fig_second_case}}}
%\caption{Simulation results}
%\label{fig_sim}
%\end{figure*}
%
% Note that often IEEE papers with subfigures do not employ subfigure
% captions (using the optional argument to \subfloat), but instead will
% reference/describe all of them (a), (b), etc., within the main caption.


% An example of a floating table. Note that, for IEEE style tables, the 
% \caption command should come BEFORE the table. Table text will default to
% \footnotesize as IEEE normally uses this smaller font for tables.
% The \label must come after \caption as always.
%
%\begin{table}[!t]
%% increase table row spacing, adjust to taste
%\renewcommand{\arraystretch}{1.3}
% if using array.sty, it might be a good idea to tweak the value of
% \extrarowheight as needed to properly center the text within the cells
%\caption{An Example of a Table}
%\label{table_example}
%\centering
%% Some packages, such as MDW tools, offer better commands for making tables
%% than the plain LaTeX2e tabular which is used here.
%\begin{tabular}{|c||c|}
%\hline
%One & Two\\
%\hline
%Three & Four\\
%\hline
%\end{tabular}
%\end{table}


% Note that IEEE does not put floats in the very first column - or typically
% anywhere on the first page for that matter. Also, in-text middle ("here")
% positioning is not used. Most IEEE journals use top floats exclusively.
% Note that, LaTeX2e, unlike IEEE journals, places footnotes above bottom
% floats. This can be corrected via the \fnbelowfloat command of the
% stfloats package.


\section{Design and Development}
\label{sec:design-dev}

\subsection{Core Ideas}
\label{subsec:core-ideas}
\textbf{\RefPerSys~ is a long term risky
  \href{https://en.wikipedia.org/wiki/Research}{research} project with
  an \href{https://en.wikipedia.org/wiki/Open_science}{open science}
  mindset and
  \href{https://ropensci.github.io/reproducibility-guide/sections/introduction/}{reproducible
    experiment} ethics \cite{zuboff:2015:big-other,
    oneil:2016:weapons}, and a
  \href{https://www.gnu.org/philosophy/free-sw.en.html}{free software}
  licensed under
  \href{https://www.gnu.org/licenses/gpl-3.0.html}{GPLv3+}, and
  targetted \emph{only} for \textsc{Linux x86-64} computers.}. A Linux
system with at least 16 Gibytes of RAM, 4 \textit{x86-64} cores, and
220 Gibytes of disk is required. The grand ambition of {\RefPerSys} is
to become later an infrastructure for some strong
\href{https://en.wikipedia.org/wiki/Artificial_general_intelligence}{AGI}
system à la \textsc{Caia} by Jacques
Pitrat \cite{Pitrat:1996:FGCS, Pitrat:2009:AST,
  Pitrat:2009:ArtifBeings}, but before even approaching that goal a
lot of work is required, and {\RefPerSys} should be valuable by
itself for other less ambitious and more pragmatic purposes, perhaps
some specialized collaborative web server (GPLv3+) to ease
communication between human {\RefPerSys} developers, that is a mix of
a wiki, a chat, and a tool for sharing document with drawings or
graphics.

The development of {\RefPerSys} is (like the one of \texttt{bismon},
or
\href{http://bootstrappingartificialintelligence.fr/WordPress3/?s=CAIA}{of
  \textsc{Caia}}) a slow, incremental and gradual
\href{https://en.wikipedia.org/wiki/Bootstrapping}{bootstrapping}
process with a meta-programming \cite{dormoy:1992:meta,
  hernandez-phillips:2019:debugging-bootstrap} approach : features
added to {\RefPerSys} in January 2020 are used to implement new
features worked on a later {\RefPerSys} in March 2020.

As every practical software, {\RefPerSys} targets some defined
machines: common Linux distribution running on some
computer\footnote{For several years, that computer is a desktop or
powerful laptop running some \textsc{Debian}. Later that could be some
``virtual machine'' e.g. some
\href{https://www.docker.com/}{\textsc{Docker}} container.}. So the
target machine of {\RefPerSys} is a quite complete and modern Linux
system (such as a recent \textit{\textsc{Debian}} or
\textit{\textsc{Ubuntu}} desktop), with many useful packages, and
administered by some human person. The {\RefPerSys} system is published in
``source'' form, as a set of \href{http://git-scm.com/}{\texttt{git}}
versioned\footnote{We crucially depend upon \texttt{git}
\emph{specifically} (e.g. \href{http://gitlab.org/}{\texttt{GitLab}}),
and \href{https://en.wikipedia.org/wiki/Porting}{porting} {\RefPerSys}
to some other versioning system -or to some other
\href{http://pages.cs.wisc.edu/~remzi/OSTEP/}{operating system} than
\textsc{Linux}- would be a quite difficult task.} textual files
(e.g. hopefully generated \textit{C} files\footnote{However, notice that
bootstrapped language implementations like
\href{http://s48.org/}{Scheme 48} or \href{https://ocaml.org/}{OCaml}
are keeping some
\href{https://en.wikipedia.org/wiki/Bytecode}{bytecode} form under
version control, and \href{https://www.call-cc.org/}{\textsc{Chicken
    Scheme}} is, like \texttt{bismon}, \texttt{git}-keeping generated
C files.}, perhaps some
\href{https://en.wikipedia.org/wiki/Makefile}{\texttt{Makefile}} or
better yet an
\href{http://projects.camlcity.org/projects/omake.html}{\textsc{OMake}}
build -most and more and more of them being generated- or shell files or
data files). Some of these files are generated, and the bootstrapping
goal is to have \emph{every} \texttt{git}-registered textual file been
generated by {\RefPerSys}, with a
\href{https://en.wikipedia.org/wiki/Bootstrapping\_(compilers)}{\textbf{bootstrap}ed}
approach\footnote{Observe that Linux source distributions like \href{http://www.linuxfromscratch.org/}{\texttt{linuxfromscratch.org}}, or to a lesser extent \href{https://www.gentoo.org/}{GenToo}, are also, when considered as a single system, fully bootstrapped.} similar to those of
\href{https://en.wikipedia.org/wiki/Self-hosting_(compilers)}{self-hosting
  compilers}.
\medskip

Within {\RefPerSys}, we call ``source file'' any Linux file which is
\texttt{git}-versioned. We hope that more and more of these source
files will be generated by the \texttt{refpersys}
\href{https://en.wikipedia.org/wiki/Executable\_and\_Linkable_Format}{ELF}
\href{https://en.wikipedia.org/wiki/Executable}{executable}
program. \textbf{A significant milestone is the entire bootstrapping
  of \RefPerSys}, when all files (in textual form, to stay
\texttt{git}-friendly, like
\href{https://en.wikipedia.org/wiki/Text-based_protocol}{text based
  protocols} are more friendly for developers) can be regenerated by
the \texttt{refpersys} executable, exactly in the same state as they
were previously\footnote{Pedantically, some
\href{https://en.wikipedia.org/wiki/Fixed\_point\_(mathematics)}{fixpoint}
of some very coarse-grained
\href{https://en.wikipedia.org/wiki/Operational\_semantics}{operational
  semantics} related to
\href{https://en.wikipedia.org/wiki/Abstract\_interpretation}{abstract
  interpretation} and
\href{https://en.wikipedia.org/wiki/Operational\_semantics\#Structural\_operational\_semantics}{big
  step semantics}, each big step being the entire regeneration of the
system, inspired by Futurama projections and
\href{https://en.wikipedia.org/wiki/Partial\_evaluation}{partial
  evaluation}.} : as a whole, our {\RefPerSys} system should become a
\href{https://en.wikipedia.org/wiki/Quine\_(computing)}{Quine
  program}, and \textsc{Caia} is already one. So the
\href{https://en.wikipedia.org/wiki/Build\_automation}{build
  automation} tool which compiles {\RefPerSys} should use file
contents, not modification times to trigger compilation commands,
since a full regeneration of such a bootstrapped {\RefPerSys} system
will touch all files, without changing the content of any of
them. Hence and very concretely, for building {\RefPerSys} the
\href{http://projects.camlcity.org/projects/omake.html}{\texttt{OMake}}
build automation tool is preferable to \textsc{Gnu}
\href{https://www.gnu.org/software/make/}{\texttt{make}}.

For pragmatical reasons, \textbf{{\RefPerSys} needs a good
  \href{https://en.wikipedia.org/wiki/Tracing\_garbage\_collection}{garbage
    collector}} (or GC \cite{appel:1991:garbage,
  wilson:1992:uniprocessorgc, baker:1995:cons,
  jones:2016:gchandbook}), since fully compile-time GC
\cite{mazur:2004:compile} are too difficult to implement. Since
multi-core x86-64 machines are very common, it should take advantage
of them, so \textbf{{\RefPerSys} should follow a
  \href{https://en.wikipedia.org/wiki/Thread_(computing)}{multi-threaded}
  approach} above \textsc{Posix} \cite{barney:2010:pthreads} or
\href{https://en.cppreference.com/w/cpp/thread}{C++11 threads}. Our GC
should be a
\href{https://en.wikipedia.org/wiki/Tracing_garbage_collection#Precise_vs._conservative_and_internal_pointers}{precise}
garbage collector \cite{Rafkind:2009:PreciseGC} and we may want to
favor, like what was done in \textsc{Gcc Melt}
\cite{Starynkevitch:2007:Multistage, Starynkevitch-DSL2011,
  Starynkevitch-GCCMELTweb}, fast allocation of small memory zones
which get quickly disposed of when becoming dead using a copying
generational
\href{https://en.wikipedia.org/wiki/Cheney's\_algorithm}{Cheney-like
  GC algorithm} \cite{wilson:1992:uniprocessorgc}.  But mixing
precise, sometimes generational GC techniques with multi-threading is
a difficult programming task. But precise-GC friendly programming is
simpler in generated C or C++ code that with hand-written code
(because of explicit management of local GC roots and write barriers,
à la
\href{http://starynkevitch.net/Basile/qishintro.html}{\textsc{Qish}}
or
\href{https://caml.inria.fr/pub/docs/manual-ocaml/intfc.html}{\textsc{Ocaml}}:
garbage collection invariants are boring and brittle to maintain in
hand-written code).


\href{https://en.wikipedia.org/wiki/Reification_(computer_science)}{Reification}
is an important concept in \RefPerSys, including (later) at the
\href{https://en.wikipedia.org/wiki/Knowledge_representation_and_reasoning}{knowledge
  representation} level with
\href{https://en.wikipedia.org/wiki/Semantic_network}{semantic
  networks} and
\href{https://en.wikipedia.org/wiki/Frame_(artificial_intelligence)}{frames}. {\RefPerSys}
\href{https://en.wikipedia.org/wiki/Call_stack}{call stacks} are made
of call frames known to our garbage collector (like
\href{https://caml.inria.fr/pub/docs/manual-ocaml/intfc.html}{\textsc{Ocaml}}'s
ones). They could later be copied into data structures representing
some
\href{https://en.wikipedia.org/wiki/Delimited_continuation}{delimited
  continuations} \cite{Reynolds:1993:continuations,
  Queinnec:2004:ContinWeb}, perhaps even representing and describing
control \cite{fouet-starynkevitch:describing-control:1987,
  Starynkevitch-1990-EUM, Pitrat:2009:ArtifBeings}. This should also
enable \textbf{introspection}, by permitting primitives inspecting the
current call stack, perhaps using Ian Taylor's
\href{https://github.com/ianlancetaylor/libbacktrace}{\texttt{libbacktrace}}. Also,
such an introspection might perhaps be implemented \cite{mitchell:2001:alp} with two nearly
twin \texttt{refpersys} processes, one of them driving a \texttt{gdb}
process\footnote{Imagine some
\href{http://man7.org/linux/man-pages/man3/popen.3.html}{\texttt{popen}}
or some
\href{https://developer.gnome.org/glib/stable/glib-Spawning-Processes.html\#g-spawn-async}{\texttt{g\_spawn\_async}}
or some
\href{https://pocoproject.org/docs/Poco.Process.html}{\texttt{Poco::Process}}
of some \texttt{gdb refpersys 1234} process debugging the other one of
pid 1234.}.

{\RefPerSys} should (like \textsc{Caia} and its predecessor
\textsc{Malice} did
\cite{Pitrat:2009:AST,Pitrat:1996:FGCS,Pitrat:2009:ArtifBeings}) have
some expert system shell \cite{kumar:2015:importance-expert-systems,
  nigro:2008:meta} and meta-rules to ``dynamically compile'' some
subset of expert system rules and knowledge bases to procedural code
(e.g. with a metaprogramming approach of generating \emph{C} code, or
\href{https://gcc.gnu.org/onlinedocs/jit/}{\texttt{libgccjit}}
compiled code, then
\href{http://man7.org/linux/man-pages/man3/dlopen.3.html}{\texttt{dlopen(3)}}-ing
that code and running it at runtime. The
\href{https://github.com/bstarynk/misc-basile/blob/master/manydl.c}{\texttt{manydl.c}}
program show that this can practically be done many dozen of thousands
of times on Linux desktops).

{\RefPerSys} will extensively use
\href{https://en.wikipedia.org/wiki/Metaprogramming}{\textbf{metaprogramming}}
techniques, so it \textbf{should generate code} (like \textsc{Caia}
do) in a
\href{https://en.wikipedia.org/wiki/Source-to-source_compiler}{transpiler}
approach (in C, C++, -compiled into
\href{https://en.wikipedia.org/wiki/Plug-in\_(computing)}{plugins} and
later
\href{https://en.wikipedia.org/wiki/Dynamic\_loading}{dynamically
  loaded} with \href{}{\texttt{dlopen(3)}}- maybe also JavaScript and
HTML5 if we decide to have a web user interface). {\RefPerSys} could
also later use
\href{https://en.wikipedia.org/wiki/Just-in-time_compilation}{just-in-time
  compilation} libraries such as
\href{https://gcc.gnu.org/onlinedocs/jit/}{\texttt{libgccjit}}. The
domain-specific language of \RefPerSys\footnote{That domain-specific
language has to be defined and implemented in a bootstrapped manner.}
(a declarative one, with ``expert system rules'') should gradually
increase its expressiveness and become more and more declarative and
closer to mathematical formalisms.

Most Linux distributions contain lots of useful libraries or software
components for {\RefPerSys} long-term goals, notably machine learning
open source libraries like
\href{https://www.tensorflow.org/}{\textsc{TensorFlow}}
\cite{charniak:2019:deep-learning, shalev:2014:understanding} or
\href{https://gudhi.inria.fr/}{\textsc{Gudhi}}
\cite{chazal:2016:high}. We might at some point also need messaging
libraries like \href{https://zeromq.org/}{\textsc{0mq}}, graphical
user interfaces libraries à la \href{http://qt.io/}{\textsc{Qt}} or
more probably web servicing libraries like
\href{https://github.com/davidmoreno/onion/}{\texttt{libonion}} or
\href{https://www.webtoolkit.eu/wt}{\textsc{Wt}}. To decrease efforts,
we don't want to rewrite such libraries inside {\RefPerSys}
(considered as a very high level,
\href{https://en.wikipedia.org/wiki/Declarative\_programming}{declarative},
\href{https://en.wikipedia.org/wiki/Domain-specific\_language}{domain-specific
  language}). Hence, we will need in {\RefPerSys} to generate some
glue code, like \href{http://swig.org/}{\textsc{Swig}} does, from some
\textbf{declarative description} (probably some frames or knowledge
bases) of the
\href{https://en.wikipedia.org/wiki/Application_programming_interface}{API}
of these available libraries.

{\RefPerSys} should at first be \textbf{orthogonally
  \href{https://en.wikipedia.org/wiki/Persistence\_(computer\_science)}{persistent}}. Like
\textsc{Bismon} \cite{Starynkevitch:2019:bismon-draft} it will load
its state (its entire garbage-collected
\href{https://en.wikipedia.org/wiki/Memory\_management#HEAP}{heap})
from files at startup, and will dump its state\footnote{In a manner
inspired by \textsc{Sbcl}
\href{http://www.sbcl.org/manual/index.html\#Saving-a-Core-Image}{\texttt{save-lisp-and-die}}
primitive, or \href{https://www.polyml.org/}{\textsc{PolyML}}
\href{https://www.polyml.org/documentation/Reference/PolyMLStructure.html\#export}{\texttt{export}}
primitive, or
\href{https://en.wikipedia.org/wiki/Marshalling_(computer_science)}{marshalling}
\href{https://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html}{facilities} of \textsc{OCaml} or \textsc{Python}
\href{https://docs.python.org/3/library/pickle.html}{\texttt{pickle}}
module.} into files at shutdown. These state files are
textual, in \href{http://json.org/}{\textsc{Json}} format, and \texttt{git}-versioned, and should be portable to
other 64 bits Linux computers. A
\href{https://en.wikipedia.org/wiki/Manifest\_file}{manifest file}
describing the collection of files keeping the state is probably
needed.


\subsection{Development Cycle}
\label{subsec:dev-cycle}

Ordinary software projects tend to follow a spiral development model
\cite{boehm:1988:spiral}.
But \RefPerSys' development follows a
\href{https://en.wikipedia.org/wiki/Strange_loop}{strange loop}
\cite{hofstadter:2007:strange-loop}, since it is bootstrapped in an
\href{https://en.wikipedia.org/wiki/Software\_prototyping\#Evolutionary\_prototyping}{evolutionary
  prototyping} manner. It is more like a spiral staircase like in
figure \ref{fig:bootstrap-stair}. The initial (floor) is just a
persistent system, and we gradually add new code implementing more
features (first entirely hand-written, later more and more parts of it
replaced by {\RefPerSys} generated code). Of course the fun is in
replacing existing hand-written code (or low-level DSL) by more
expressive and generated one. So we will continuously rewrite past
formalizations as a more clever and expressive ones, taking more and
more advantage of {\RefPerSys} whole-system introspective abilities.
All of \href{https://en.wikipedia.org/wiki/Eurisko}{\textsc{Eurisko}}
\cite{Lenat:1983:Eurisko},
\href{https://en.wikipedia.org/wiki/Cyc}{\textsc{Cyc}}
\cite{Lenat:1991:ev-cycl} and
\href{https://en.wikipedia.org/wiki/Self\_(programming_language)}{\textsc{Self}}\footnote{\textsc{Self}
was even able (in hours of CPU time) to redefines its integers -even
for arithmetic used inside its compiler- as
\href{https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic}{bignums}.}
\cite{chambers:1991:efficient} (or even
\href{https://iolanguage.org/}{\textsc{Io}} or
\href{https://en.wikipedia.org/wiki/Smalltalk}{\textsc{Smalltalk}})
systems and their incremental development process are inspirational.

The first significant milestone of {\RefPerSys} should be the ability
to re-generate all its textual source files (and maybe even
\texttt{git add} then\texttt{git commit} them). That would require
first implementing some simple template based
machinery\footnote{Perhaps inspired by simple designs like
  \href{https://docs.djangoproject.com/en/2.2/topics/templates/}{\textsc{Django}
    tempates}, but driven by frame-based {\RefPerSys} objects.}, withe
the ability, like
\href{https://en.wikipedia.org/wiki/Quine\_(computing)}{\textsc{Quine}}
programs do, to regenerate all {\RefPerSys} source code (e.g. in C++,
a \texttt{Makefile}, etc...). Actually {\RefPerSys} needs to
conceptually have \textbf{self-modifying code}
\cite{Tschudin:2005:HarnessingSC}, practically implemented by
systematically doing most function calls through indirect function
pointers (which gets updated with
\href{http://man7.org/linux/man-pages/man3/dlsym.3.html}{\texttt{dlsym(3)}}).


\subsection{Metaprogramming and introspection approach}
\label{subsec:metaprog-introspec}

\textbf{Metaprogramming} \index{metaprogramming} is defined
\href{https://en.wikipedia.org/wiki/Metaprogramming}{in Wikipedia} as
``a programming technique in which computer programs have the ability
to treat other programs as their data. It means that a program can be
designed to read, generate, analyze or transform other programs, and
even modify itself while running''. That design idea is central to
many Artificial Intelligence systems and AI inspired
languages\footnote{See also \href{http://s48.org}{\textsc{Scheme 48}},
\href{http://sbcl.org/}{\textsc{SBCL}},
\href{http://https://www.rust-lang.org/}{\textsc{Rust}}, even
\href{https://en.cppreference.com/w/cpp/language/templates}{C++
  \emph{templates}}, \href{https://www.call-cc.org/}{\textsc{Chicken
    Scheme}}, \href{
  http://okmij.org/ftp/ML/MetaOCaml.html}{\textsc{MetaOCaml}}, the
\href{http://eclipseclp.org/}{\textsc{ECLiPSe} Constraint Programming
  System}, \href{https://www.rascal-mpl.org/}{\textsc{Rascal}},
\href{http://nemerle.org/}{\textsc{Nemerle}},
\href{http://coccinelle.lip6.fr/}{\textsc{Coccinelle}},
\href{{https://ocsigen.org/}}{\textsc{Ocsigen}},
\href{http://www.gprolog.org/}{\textsc{Gnu Prolog}},
\href{http://www.clipsrules.net/}{\textsc{Clips}},
\href{https://logological.org/gpp}{\textsc{Gpp}},
\href{http://swig.org/}{\textsc{Swig}},
\href{https://www.antlr.org/}{\textsc{Antlr}},
\href{https://github.com/drh/iburg}{\textsc{Iburg}},
\href{https://www.gnu.org/software/bison/}{Gnu \textsc{Bison}}, etc
\ldots} and is also common in software engineering\footnote{A typical
example is the \href{http://gcc.gnu.org}{\textsc{GCC}} compiler, or
\href{https://en.wikipedia.org/wiki/Autoconf}{\textsc{Autoconf}}, and
\href{https://en.wikipedia.org/wiki/Source-to-source_compiler}{transpiler
  approaches}} \cite{Lenat:1983:Eurisko, Lenat:1983:theory,
  Lenat:1991:ev-cycl, Pitrat:1996:FGCS, Pitrat:2009:AST,
  Pitrat:2009:ArtifBeings, Pitrat:blog, Queinnec:1996:LSP,
  Queinnec:2004:ContinWeb, Starynkevitch-1990-EUM,
  Starynkevitch-DSL2011, Starynkevitch-GCCMELTweb,
  Starynkevitch:2007:Multistage, Starynkevitch:2019:bismon-draft,
  Tschudin:2005:HarnessingSC, abelson:1996:sicp, briot:1987:uniform,
  chambers:1991:efficient, cointe:1987:metaclasses, dormoy:1992:meta,
  fouet-starynkevitch:describing-control:1987,
  greiner:1980:representation,
  hernandez-phillips:2019:debugging-bootstrap,hofstadter:2007:strange-loop,
  kay:1996:early-smalltalk, kelsey:1998:r5rs,
  kumar:2015:importance-expert-systems, matthews:2005:operational,
  mazur:2004:compile, nigro:2008:meta, queinnec:2003:lisp,
  Starynkevitch:2009:grow, serrano:1995:bigloo}.  Generating some
``source'' code at build time is usual practice, advocated also by the
\href{https://ninja-build.org/}{\textsc{Ninja} build system}, and
theorized (around 1930, before even computers existed) in the
\href{https://en.wikipedia.org/wiki/Church-Turing_thesis}{\textsc{Church-Turing}
  thesis}. Related concepts include the famous (but
\href{https://en.wikipedia.org/wiki/Undecidable_problem}{undecidable})
\href{https://en.wikipedia.org/wiki/Halting_problem}{\textbf{halting
    problem}} (whose proof involves a metaprogramming approach
\cite{Hofstadter:1979:GEB}),
\href{https://en.wikipedia.org/wiki/Hygienic_macro}{hygienic macros},
and \href{https://en.wikipedia.org/wiki/Rice's_theorem}{Rice's
  theorem}.

Practically speaking \cite{abelson:1996:sicp}, metaprogramming is
easier achieved by explicitly representing (maybe incomplete) code
with
\href{https://en.wikipedia.org/wiki/Abstract_syntax_tree}{abstract
  syntax trees} \index{abstract syntax tree} \index{tree!abstract
  syntax} (or \index{AST} AST), maybe with some holes for
\href{https://en.wikipedia.org/wiki/Metavariable}{metavariables} for
their later
\href{https://en.wikipedia.org/wiki/Explicit_substitution}{explicit
  substitution}, in the spirit of
\href{https://docs.djangoproject.com/en/2.2/topics/templates/}{\textsc{Django}
  templates} or of
\href{https://lispcookbook.github.io/cl-cookbook/macros.html}{\textsc{Common
    Lisp} macros} or
\href{https://en.wikibooks.org/wiki/Scheme_Programming/Macros}{\textsc{Scheme}
  macros}. A practical way to implement such a template machinery for
generating C or C++ code is given by
\href{https://gcc.gnu.org/wiki/MELT tutorial}{\textsc{GCC MELT} code
  chunks} \cite{Starynkevitch-DSL2011, Starynkevitch-GCCMELTweb,
  Starynkevitch:2009:grow, Starynkevitch:2007:Multistage}, where a
piece of C (or C++) code with holes (or metavariables)
is passed through a ``macro-string''.
Later, such a macro-string or code chunk can be expanded by filling
the holes, that is expanding the metavariables (e.g.\texttt{\$msg})
appropriately. Such an expansion might be recursive, since some hole
filling (or metavariable replacement) could in turn trigger expansions
of other macro-strings. In practice, {\RefPerSys} will use similar
code chunks and macro-expansion to generate its C (or C++) code, and
some initial ad-hoc
\href{https://en.wikipedia.org/wiki/Integrated_development_environment}{integrated
  development environment} \index{integrated development environment}
(or \index{IDE} IDE) will have to be coded, handling passively some
persistent store. The expansion will be done through some scripting
language (or \emph{domain specific language}, a.k.a. DSL) which has to
be implemented inside our IDE.


Metaprogramming involves code generation (using
\href{https://en.wikipedia.org/wiki/Source-to-source_compiler}{source-to-source}
ahead-of-time and/or
\href{https://en.wikipedia.org/wiki/Just-in-time_compilation}{just-in-time}\footnote{Several
JIT compilation libraries exist, notably
\href{https://gcc.gnu.org/onlinedocs/jit/}{\texttt{libgccjit}}
provided inside recent \href{http://gcc.gnu.org}{\textsc{GCC}}
compilers.} compilation techniques \cite{Aho:2006:dragon-book}, and in
     {\RefPerSys} is useful for many tasks, such as generating the
     garbage collection support routines for scanning or forwarding,
     and the loading and dumping routines needed for persistence (in
     the spirit of
     \href{https://en.wikipedia.org/wiki/RPCGEN}{\textsc{RpcGen}},
     \href{http://swig.org/}{\textsc{Swig}} and other
     \href{https://en.wikipedia.org/wiki/Serialization}{serialization}
     frameworks).

 In \RefPerSys, metaprogramming is often and practically achieved
 (like in \cite{Starynkevitch-DSL2011,
   Starynkevitch:2019:bismon-draft, Pitrat:1996:FGCS,
   Pitrat:2009:ArtifBeings} and our
 \href{https://github.com/bstarynk/misc-basile/blob/master/manydl.c}{\texttt{manydl.c}}
 example program), by generating some C or C++ code in a temporary
 file\footnote{There are practical reasons to generate these temporary
 files outside of \texttt{/tmp/}, which gets cleaned at reboot.} like
 \texttt{/tmp/rpsgen123.c}, compiling that file
 \cite{drepper:2011:write-shared-lib} into a generated plugin
 \texttt{/tmp/rpsgen123.so} by running a process such as
        {\relsize{-1}{\texttt{gcc -fPIC -Wall -O -g -shared
              /tmp/rpsgen123.c -l\textit{something} -o
              /tmp/rpsgen123.so}}} and waiting for its successful
        completion, then
        \href{http://man7.org/linux/man-pages/man3/dlopen.3.html}{\texttt{dlopen(3)}}-ing
        that newly generated \texttt{/tmp/rpsgen123.so}, in a manner
        compatible with our garbage collection and agenda
        invariants. We might later care about carefully
        \href{http://man7.org/linux/man-pages/man3/dlclose.3.html}{\texttt{dlclose(3)}}-ing
        that generated plugin, but in practice we accept some limited
        virtual memory plugin leak, and we could just dump
        appropriately our persistent state by mentioning in some
        generated
        \href{https://en.wikipedia.org/wiki/Manifest_file}{Manifest
          file} those plugins which should be saved (as generated C
        code) with the state.

\href{https://en.wikipedia.org/wiki/Reflection_(computer_programming)}{Reflection}
is ``the ability of a process to examine, introspect, and modify its
own structure and behavior'' and also, for
\href{https://en.wikipedia.org/wiki/Self-reflection}{self-reflection},
the capacity `` to exercise introspection and to attempt to learn more
about their fundamental nature and essence''. (Wikipedia). It is
advocated (in \cite{Pitrat:2009:ArtifBeings}) that a similar approach
is (painfully) achievable in AI systems, and it would need both clever
\href{https://en.wikipedia.org/wiki/Backtracking}{backtracking} and
\href{https://en.wikipedia.org/wiki/Stack_trace}{backtracing}
techniques.
 Libraries such as Ian Taylor's
 \href{https://github.com/ianlancetaylor/libbacktrace}{\texttt{libbacktrace}}
 (which wants most of the code to be compiled with
 \href{https://en.wikipedia.org/wiki/DWARF}{\textsc{Dwarf} debugging}
 information\footnote{In practice we should compile our or other C or
 C++ code with both \texttt{-O2 -g} passed while
 \href{https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html}{invoking}
 \texttt{GCC} or \texttt{g++}, and this is indeed possible and
 practically works well enough.}) are helpful.

 Our precise garbage collector (see \S \ref{sec:dataobjmodel} below
 and \cite{rafkind:2009:precise-gc}, or
 \href{http://starynkevitch.net/Basile/qishintro.html}{\textsc{Qish}})
 wants local variables holding garbage collected pointers to be known
 to the GC. In practice, the {\RefPerSys} call frame is some explicit
 local \texttt{struct} named \texttt{\_} in generated C
 code\footnote{Like \href{http://github.com/bstarynk/bismon/}{Bismon}
 does, see its \texttt{LOCAL\_BM} macro. See also the
 \texttt{CAMLparam$i$} and \texttt{CAMLlocal$j$} C macros of
 \href{https://caml.inria.fr/pub/docs/manual-ocaml/intfc.htm}{\textsc{OCaml}},
 and the \texttt{Py\_VISIT} and \texttt{Py\_DECREF} and other macros
 of
 \href{https://docs.python.org/3/extending/}{\textsc{Python}}, the \href{http://www.sbcl.org/manual/index.html\#Foreign-Function-Interface}{\textit{foreign function interface} of \textsc{SBCL}}, etc \ldots}. Such
 explicited local frames can often be optimized by \texttt{GCC} or
 \texttt{g++} (invoked with \texttt{-O2}).

 As suggested by Pitrat (see \cite{Pitrat:1996:FGCS, Pitrat:2009:AST,
   Pitrat:2009:ArtifBeings}), call stack reflection and backtrace is
 the elementary brick of more sophisticated \emph{introspection}
 techniques. At some point, our {\RefPerSys} system should inspect its
 call stack and may take decisions after that. A typical approach
 would be to run such introspection once in a while (e.g. every 0.1
 second on the average\footnote{Timing considerations are essential,
 practically speaking, in \RefPerSys. See
 \href{http://man7.org/linux/man-pages/man7/time.7.html}{\texttt{time(7)}}
 man page.}, in the
 \href{https://en.wikipedia.org/wiki/Inference_engine}{inference
   engine} of some
 \href{https://en.wikipedia.org/wiki/Expert\_system}{expert system} or
 \href{https://en.wikipedia.org/wiki/Knowledge_base}{knowledge base}
 component of {\RefPerSys}.
 
 Since we aim to be able to re-generate most (and hopefully all) of
 {\RefPerSys} code (in C or in C++), having simple \textbf{coding
   conventions} does matter: every \RefPerSys-defined C or C++
 identifier should start with \texttt{rps\_} in lower, upper, or mixed
 case (e.g. also \texttt{RPS\_} or \texttt{Rps\_}). Every C or C++
 function, even \texttt{static inline} ones appearing in header files,
 has its name starting with \texttt{rps\_} and is \emph{globally}
 unique to the entire \texttt{refpersys} program. The C (or C++) code
 should be automatically indented\footnote{With the social convention
 that {\RefPerSys} contributors are running \texttt{omake indent} or
 \texttt{make indent} before every \texttt{git commit}!} using
 \href{https://www.gnu.org/software/indent/}{Gnu \textsc{Indent}} or
 \href{http://astyle.sourceforge.net/}{\textsc{Astyle}}. Every named
 \texttt{struct} (in C) should have its tag matching
 \texttt{rps\_*st}. Every \texttt{typedef}-ed data type should have
 its name matching \texttt{rps\_*t}. Every named \texttt{enum} should
 have its tag matching \texttt{rps\_*en} and the various enumerated
 values like \texttt{RPS\_*}. Even in cases the C (or the C++)
 language allows several name spaces, we don't use that facility. 
 Hence we avoid coding the
 common \texttt{typedef struct rpsfoo\_t rpsfoo\_t;} but prefer
 instead (inspired by \href{http://gtk.org}{\textsc{Gtk}}) coding
 \texttt{typedef struct rps\_\textit{foo}\_st
   rps\_\textit{foo}\_t}. Of course, names of
 \href{https://en.wikipedia.org/wiki/Local\_variable}{local variables}
 (that is
 \href{https://en.wikipedia.org/wiki/Automatic_variable}{automatic
   variables} with their
 \href{https://en.wikipedia.org/wiki/Scope\_(computer\_science)\#Lexical\_scoping}{lexical
   scope} limited to some small C or C++
 \href{https://en.wikipedia.org/wiki/Block\_(programming)}{block})
 could be as short as a single letter such as \texttt{i}. In general,
 our C or C++ code is written with the hope of being easily able to
 regenerate it.


\subsection{The persistent heap}
\label{subsec:persistheap}

When {\RefPerSys} is running in some multi-threaded \textsc{Linux}
\href{https://en.wikipedia.org/wiki/Process\_(computing)}{process},
the {\RefPerSys} persistent heap is (like Bismon's one
\cite{Starynkevitch:2019:bismon-draft}) semantically like the memory
heap of most
\href{https://en.wikipedia.org/wiki/Dynamic\_programming\_language}{dynamic
  programming languages} (such as
\href{https://python.org/}{\textsc{Python}},
\href{https://www.gnu.org/software/guile/}{\textsc{Guile}},
\href{https://golang.org/}{\textsc{Go}},
\href{http://sbcl.org/}{\textsc{Sbcl}}, etc \ldots).
  We strongly want
to avoid any
\href{https://en.wikipedia.org/wiki/Global\_interpreter\_lock}{GIL},
but multi-threaded precise efficient garbage collector implementations
are quite difficult to code. However, notice that the persistence
(dump as textual \texttt{git}-versioned disk files) of a heap uses
algorithms similar to those of copying garbage collectors
\cite{wilson:1992:uniprocessorgc, jones:2016:gchandbook}.


Conceptually, {\RefPerSys}
\href{https://en.wikipedia.org/wiki/Tracing_garbage_collection}{tracing
  precise garbage collector} should traverse the graph of references
to {\RefPerSys} values, starting from global or transient roots and
local variables inside call frames of working threads. Each
{\RefPerSys} \textbf{value} \index{value} (immutable or object) is
represented by a machine word (aligned, 64 bits) which usually
contains a pointer, but sometimes some
\href{https://en.wikipedia.org/wiki/Tagged\_pointer}{tagged integer}.
Immutable values are often ``small'' (typically, less than a few dozens of words of memory, sometimes a lot more) but
objects are necessarily heavier since they contain some kind of
lock. \href{https://en.wikipedia.org/wiki/Closure\_(computer_programming)}{closures}
are immutable values, containing an object representing and giving
their function code (as a C function pointer inside that object), and
additional closed values. In practice our garbage collector processes
not only values (either immutable values or objects), but also
\textbf{quasi-values} \index{quasi-value}: these are a single memory
zone which is allocated using the garbage collector allocation
protocol, traversed by the GC when something points to it, appears
inside other values (in particular, as payload \index{payload} of objects), but by
convention should not be passed as a genuine value.
Some values (or objects) may be dead and should eventually be reclaimed by the
garbage collector.

\textbf{Values}, either immutable values or changeable objects, in
       {\RefPerSys} can be either \textbf{persistent} (dumped in
       textual state files\footnote{In the current implementation,
       {\RefPerSys} state files should appear under
       \texttt{persistore/} subdirectory, and the manifest file is
       \texttt{rps\_manifest.json} at the top directory.}, then
       reloaded at restart of \texttt{refpersys} process) or
       \textbf{transient} (that is, not dumped and not appearing in
       state files).

The \textbf{persistence} machinery - the dump - is conceptually simple
and could run in several threads: start from global roots and traverse
the memory graph but ignore transient objects and transient roots and
memoize previously seen persistent objects. Of course, objects should
not be persisted twice, and are referred by the \textbf{object id} or
\textbf{objid} in the state files produced by the dump. That
\textit{objid} \index{objid@\textit{objid}} is alphanumeric, randomly generated and so hopefully
globally unique -like {\relsize{-1}{\texttt{\_2om48kc3k5R02d3ktW}}}
for example- in our current implementation; exactly like
\href{https://en.wikipedia.org/wiki/Universally_unique_identifier}{\textsc{Uuid}s}
should be. Notice the conceptual similarity between {\RefPerSys} dump
algorithm and its tracing garbage collector: both are traversing the
graph of references inside the heap.

The global roots are objects. Use the C++ functions
\texttt{rps\_each\_root\_object} to iterate on them,
\texttt{rps\_add\_root\_object} to add one,
\texttt{rps\_remove\_root\_object} to remove one,
\texttt{rps\_is\_root\_object} to test if an object is a global root,
\texttt{rps\_set\_root\_objects} to get the set of all of them,
and\texttt{rps\_nb\_root\_objects} to get their number. Of course,
some global roots can be transient objects, but all of them are roots
for the garbage collector.

The initial loading machinery (recreating a suitable heap - and
rebuilding a graph of references inspired by figure
\ref{fig:persistent-heap}, without any transient stuff) from its
previous dumped state) is first creating empty all objects, then later
filling each of them. However, for efficiency, we may want to load the
heap in parallel, using several loader threads. This could be easy if,
after having created all objects as empty, and loaded plugins
(i.e. \texttt{dlopen}-ing many \texttt{*.so} files), {\RefPerSys}
processes each state file in a potentially different loading thread.

\section{Future technical roadmap}
\label{sec:future-roadmap}

The remaining roadmap has two facets: a short term technical roadmap
(not implemented yet in August 2020, but designed since half
implemented in prior work), and a more speculative self-applying
roadmap on the {\RefPerSys} system (independently of future potential
applications).

\subsection{Short term technical roadmap}
\label{shbsec:short-roadmap}

The below short term work is parallel to some of the development
already done in \textsc{Bismon}
\cite{Starynkevitch:2019:bismon-draft}, a GPLv3+
software\footnote{Bismon -on
\href{https://github.com/bstarynk/bismon}{\texttt{github.com/bstarynk/bismon/}}
runs on Linux, does have a persistent heap, has no software or API
documentation, nearly 4000 persisted objects, 25KLOC of generated C
lines and 65KLOC of hand written C lines, but design bugs related to
garbage collection and incompatible interaction with GTK which makes
it crash very often, e.g. once a few minutes!}  sharing some ideas
with \RefPerSys (but not a single line of code). It should be done in
the few months following August 2020 and present no conceptual
difficulty, since reproducing prior work (but avoiding conceptual
design bugs).

So our short term todo-list includes a few simple features (possibly
worked upon in parallel):

\begin{itemize}
  \item defining some ``read-eval-print-loop'' syntax and thinnk of
    its GUI implementation.
    
  \item hand-coding some GUI interface above FLTK (inspired by the
    existing GTK interface of \textsc{Bismon}) to enable us to
    conveniently create {\RefPerSys} objects and update them, run a
    small set of commands\footnote{In particular, dumping the
    persistent heap and generating C++ code.}, and providing
    autocompletion and minor syntax highlighting.

  \item hand-coding the initial C++ generator, with code chunks as was done in  \textsc{Melt} \cite{Starynkevitch-DSL2011}.

  \item creating and filling objects and values representing the existing C++ classes related to {\RefPerSys} objects and values.

    \item generating that C++ code, and once it is working, removing
      the old hand-written code as explained above. Using a good
      version control system such as \texttt{git} is practically
      important, for software engineering reasons and best practices.

      \item representing more abstractly the current organization and
        type system of {\RefPerSys} values (and objects) (see \S
        \ref{subsec:persistheap} above), and regenerating most of
        existing C++ declarations (e.g. in current
        \texttt{refpersys.hh} header), and simultaneously emit C++ for
        support routines for garbage collection and for
        persistence. Once that is achieved, the majority of current
        hand-written C++ code would have been replaced by generated
        C++ code.

      \item generating {\RefPerSys} closure code and method dictionaries, including our \textsc{ObjVLisp} inspired model.

        \item generate variants (perhaps thru preprocessor flags) of
          code which profile and measure the execution time of many
          short processing. Notice that on Linux time measuring
          functions\footnote{Refer to the
          \href{https://man7.org/linux/man-pages/man7/time.7.html}{\texttt{time(7)}}
          man page.} like \texttt{clock\_gettime} have very little
          overhead and runs quickly (fraction of a microsecond) and
          are able to measure reliably a few microseconds of CPU time.
\end{itemize}

The reader should notice that the above present have no conceptual
difficulties. They are similar to existing work, such as
\textsc{Bigloo}\footnote{See
\href{https://www-sop.inria.fr/mimosa/fp/Bigloo/}{\texttt{www-sop.inria.fr/mimosa/fp/Bigloo}}
for more.}  \cite{Serrano:1995:bigloo, Bres:2004:bigloo} or
\textsc{Chicken/Scheme}\footnote{See
\href{http://call-cc.org/}{\texttt{call-cc.org}}.}.

\subsection{Long term reflexive roadmap}
\label{shbsec:long-roadmap}

Once the infrastructure exists to generate most of the C++ code
(notably C++ classes describing the data, C++ code for garbage
collection and for persistence, some more speculative work remains.

{\large @@ TO BE WRITTEN}

\section{Future potential applications}
The {\RefPerSys} project needs real-life applications, which could
take advantage of its flexible object model, persistence, reflexivity
and metaprogramming abilities. Future use-cases that are considered
(within the next five years, if users are found) could include:

\begin{itemize}
\item representing wisely the documention of \RefPerSys, and
  generating some parts of it (in PDF or HTML format), probably
  starting a few \LaTeX-related Linux processes and generating some
  \texttt{*.tex} or \texttt{*.html} files.
  
  \item assistance and software tool to help building, managing and
    technically coordinating a cooperating research consortium, such
    as European H2020 or future HorizonEurope\footnote{See
      \href{https://ec.europa.eu/info/horizon-europe-next-research-and-innovation-framework-programme_en}{\texttt{ec.europa.eu/info/horizon-europe-next-research-and-innovation-framework-programme\_en}}}
    projects. Since the typical research consortium is made of many
    partner organizations, involves dozens of persons with various
    interests and skills.

\item during the current Covid health crisis (and ignoring important
  legal obstacles or ethical concerns related to privacy issues - both
  should be handled by humans), managing data and information about
  Covid handling in a city: the set of tested persons, their medical
  results (represented as {\RefPerSys} objects, the set of testing
  centers, the databases holding test results, etc...

\item in a complex industrial corporation (e.g. some automobile
  maker), facilitate the connection and coordination between existing
  software subsystems (following the ``digital twins'' dream), include
  finite elements simulation code, computer aided design related data
  and existing software tools, factory planning, etc.  {\RefPerSys}
  could then help to build an incomplete, semi-coherent and
  semi-automatic model of what is actually going on in such
  factories. Industrial parts or components (e.g. brakes), simulation
  software, databases, part movements, plant status, could be
  represented as {\RefPerSys} objects

\item etc...
  
\end{itemize}

Please contact the authors to suggest real-life uses cases, and
technical cooperation.


\section{Conclusion}
We have discussed how we are trying to develop {\RefPerSys} organically,
using metaprogramming techniques to eventually build a fully bootstrapped
Quine system. Our approach is to gradually replace hand-written code with
increasingly expressive generated code, relying on the growing metaprogramming
and reflective properties of the system. See also \cite{starynkevitch:2019:refpersys-design}.

Future work (in 2021) should include: diminushing the (currently too
large) hand-written C++ code base, increasing the amount of generated
C++ code, giving concrete know how about software development, and
working on real-life use cases provided by other users.




% if have a single appendix:
%\appendix[Proof of the Zonklar Equations]
% or
%\appendix  % for no appendix heading
% do not use \section anymore after \appendix, only \section*
% is possibly needed

% use appendices with more than one appendix
% then use \section to start each appendix
% you must declare a \section before using any
% \subsection or using \label (\appendices by itself
% starts a section numbered zero.)
%



% use section* for acknowledgement
\section*{Acknowledgment}


The authors would like to thank Nimesh Neema for testing and minor
contributions to \RefPerSys and Faré Rideau and Niklas Rosencrantz for
proof reading earlier versions of this draft.


% Can use something like this to put references on a page
% by themselves when using endfloat and the captionsoff option.
\ifCLASSOPTIONcaptionsoff
  \newpage
\fi



% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% references section

\section*{References}

%% for some reason, this does not work
%\bibliographystyle{IEEEtran}
%\bibliography{IEEEabrv,iccait2021-refpersys-biblio}

%\bibliographystyle{plain}
%\bibliography{plain,iccait2021-refpersys-biblio}

\medskip
%\printbibliography

% biography section
% 
% If you have an EPS/PDF photo (graphicx package needed) extra braces are
% needed around the contents of the optional argument to biography to prevent
% the LaTeX parser from getting confused when it sees the complicated
% \includegraphics command within an optional argument. (You could create
% your own custom macro containing the \includegraphics command to make things
% simpler here.)
%\begin{biography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{mshell}}]{Michael Shell}
% or if you just want to reserve a space for a photo:

\begin{IEEEbiographynophoto}{Basile Starynkevitch}
Lives in France
\end{IEEEbiographynophoto}

\begin{IEEEbiographynophoto}{Abhishek Chakravarti}
Lives in India
\end{IEEEbiographynophoto}


% You can push biographies down or up by placing
% a \vfill before or after them. The appropriate
% use of \vfill depends on what kind of text is
% on the last page and whether or not the columns
% are being equalized.

%\vfill

% Can be used to pull up biographies so that the bottom of the last one
% is flush with the other column.
%\enlargethispage{-5in}




%%% for a draft that should be acceptable
\begin{flushright}
  \begin{relsize}{-1}
    Our draft \texttt{git} ID is
    \texttt{\textit{\rpsgitcommit}}. Photos and biographies will be
    added later. Thi draft has been \LaTeX-ed on
    \textit{\rpstimestamp}. See our {\LaTeX} source code on
    \href{https://gitlab.com/bstarynk/refpersys/-/tree/fltk-branch/doc/iccait-2021}{gitlab.com/bstarynk/refpersys/-/tree/fltk-branch/doc/iccait-2021}
  \end{relsize}
\end{flushright}

% that's all folks
\end{document}


%%% For emacs:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Local Variables: ;;
%% compile-command: "./build.sh" ;;
%% End: ;;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
